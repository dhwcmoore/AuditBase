(* --- JSON escape helper --- *)
let json_escape s =
  let b = Buffer.create (String.length s + 8) in
  String.iter (function
    | '"'  -> Buffer.add_string b "\\\""
    | '\\' -> Buffer.add_string b "\\\\"
    | '\n' -> Buffer.add_string b "\\n"
    | '\r' -> Buffer.add_string b "\\r"
    | '\t' -> Buffer.add_string b "\\t"
    | c    -> Buffer.add_char b c
  ) s;
  Buffer.contents b
open Printf
module EI = Engine_interface

(* ---------- helpers ---------- *)
let trim s =
  let is_sp = function ' ' | '\n' | '\r' | '\t' -> true | _ -> false in
  let n = String.length s in
  let i = ref 0 and j = ref (n - 1) in
  while !i < n && is_sp s.[!i] do incr i done;
  while !j >= !i && is_sp s.[!j] do decr j done;
  if !j < !i then "" else String.sub s !i (!j - !i + 1)

let starts_with s pref =
  let ls = String.length s and lp = String.length pref in
  ls >= lp && String.sub s 0 lp = pref


let read_file path =
  let ic = open_in path in
  let b = Buffer.create 4096 in
  (try while true do Buffer.add_string b (input_line ic); Buffer.add_char b '\n' done
   with End_of_file -> ());
  close_in ic; Buffer.contents b

let parse_pair_floats s =
  let lb = String.index s '[' in
  let rb = String.rindex s ']' in
  let inner = String.sub s (lb+1) (rb - lb - 1) in
  match List.map trim (String.split_on_char ',' inner) with
  | [a;b] -> (float_of_string a, float_of_string b)
  | _ -> failwith ("bad float pair: " ^ s)

(* ---------- audit spec ---------- *)
module AT = struct
  type interval = { a:float; b:float; left_closed:bool; right_closed:bool; category:string }
  type domain_spec = {
    name : string;
    global_low : float; global_high : float;
    intervals : interval list;
    risk_order : string list option;
  }
end

(* ---------- YAML loader with fallback ---------- *)
let load_spec_from_yaml file : AT.domain_spec =
  let txt = read_file file in
  let lines = List.map trim (String.split_on_char '\n' txt) in
  let name =
    match List.find_opt (fun l -> starts_with l "name:") lines with
    | Some l ->
        let v = trim (String.sub l 5 (String.length l - 5)) in
        if String.length v >= 2 && v.[0]='"' && v.[String.length v-1]='"'
        then String.sub v 1 (String.length v-2) else v
    | None -> Filename.basename file
  in
  let gb =
    try
      match List.find_opt (fun l -> starts_with l "global_bounds:") lines with
      | Some l -> parse_pair_floats l
      | None -> raise Not_found
    with _ ->
      let d = EI.load_domain_from_file file in
      d.global_bounds
  in
  let intervals =
    let rec walk acc = function
      | [] -> List.rev acc
      | l::ls when starts_with l "- range:" ->
          let (a,b) = parse_pair_floats l in
          let cat =
            match List.find_opt (fun l2 -> starts_with (trim l2) "category:") ls with
            | Some l2 ->
                let c = trim (String.sub (trim l2) 9 (String.length (trim l2) - 9)) in
                if String.length c >= 2 && c.[0]='"' && c.[String.length c-1]='"'
                then String.sub c 1 (String.length c-2) else c
            | None -> "UNSPECIFIED"
          in
          walk ({AT.a=a;b;left_closed=true;right_closed=false;category=cat}::acc) ls
      | _::ls -> walk acc ls
    in
    match walk [] lines |> List.rev with
    | [] -> []
    | last::rest_rev -> List.rev ({last with AT.right_closed=true}::rest_rev)
  in
  { AT.name=name; global_low=fst gb; global_high=snd gb; intervals; risk_order=None }

(* ---------- classification ---------- *)
let classify name x =
  let file = Printf.sprintf "boundary_logic/domain_definitions/%s.yaml" name in
  match EI.Boundary_classifier.classify_from_yaml file (Printf.sprintf "%.12g" x) with
  | Ok r -> r.category
  | Error msg -> failwith ("classification error: " ^ msg)

(* ---------- risk order inference ---------- *)
let infer_risk_order (spec:Audit.Audit_types.domain_spec) =
  let tbl = Hashtbl.create 16 in
  let rec go acc = function
    | [] -> List.rev acc
    | iv::rest ->
        if Hashtbl.mem tbl iv.Audit.Audit_types.category then go acc rest
        else (Hashtbl.add tbl iv.Audit.Audit_types.category (); go (iv.Audit.Audit_types.category::acc) rest)
  in
  let sorted = List.sort (fun a b -> compare a.Audit.Audit_types.a b.Audit.Audit_types.a) spec.Audit.Audit_types.intervals in
  go [] sorted

(* ---------- convert ---------- *)
let to_audit_spec (d:AT.domain_spec) : Audit.Audit_types.domain_spec =
  { Audit.Audit_types.
    name=d.AT.name; global_low=d.AT.global_low; global_high=d.AT.global_high;
    intervals=List.map (fun iv->{Audit.Audit_types.a=iv.AT.a;b=iv.AT.b;left_closed=iv.AT.left_closed;right_closed=iv.AT.right_closed;category=iv.AT.category}) d.AT.intervals;
    risk_order=d.AT.risk_order }

(* ---------- run ---------- *)
let run_one ?(json=false) name =
  let file = Printf.sprintf "boundary_logic/domain_definitions/%s.yaml" name in
  let spec0 = load_spec_from_yaml file |> to_audit_spec in
  let spec = match spec0.Audit.Audit_types.risk_order with
    | None -> { spec0 with Audit.Audit_types.risk_order = Some (infer_risk_order spec0) }
    | Some _ -> spec0
  in
  let (dn, monos, failures) =
    Audit.Audit_runner.run_domain ~spec ~classify:(classify name)
  in
  let mono_ok = List.for_all (fun b -> b) monos in
  let ok = mono_ok && failures = [] in
  if json then begin
    let failures_json =
      failures
      |> List.map (fun (k,x) -> Printf.sprintf {|{"kind":"%s","x":%.12g}|} (json_escape k) x)
      |> String.concat ","
    in
    Printf.printf {|{"domain":"%s","monotonicity":%b,"failures":[%s]}|} dn mono_ok failures_json;
    print_newline ();
  end else begin
    Printf.printf "== Audit: %s ==\n" dn;
    Printf.printf "  Monotonicity: %s\n" (if mono_ok then "PASS" else "FAIL");
    if failures = [] then Printf.printf "  Gaps/Overlaps: PASS\n"
    else begin
      Printf.printf "  Gaps/Overlaps: FAIL (%d)\n" (List.length failures);
      List.iter (fun (k,x) -> Printf.printf "    %s at x=%.12g\n" k x) failures
    end;
  end;
  ok
let list_domains () =
  Sys.readdir "boundary_logic/domain_definitions"
  |> Array.to_list
  |> List.filter (fun f->Filename.check_suffix f ".yaml")
  |> List.map (fun f->Filename.chop_suffix f ".yaml")
  |> List.sort String.compare

let () =
  match Array.to_list Sys.argv |> List.tl with
  | ["--domain"; d] -> ignore (run_one d)
  | ["--domain"; d; "--json"] -> if run_one ~json:true d then exit 0 else exit 1
  | ["--all"] ->
      let oks = list_domains () |> List.map run_one in
      if List.for_all (fun x->x) oks then exit 0 else exit 1
  | ["--all"; "--json"] ->
      let oks = list_domains () |> List.map (run_one ~json:true) in
      if List.for_all (fun x->x) oks then exit 0 else exit 1
  | _ ->
      eprintf "Usage: audit_main.exe --domain <name> [--json] | --all [--json]\n"; exit 2
